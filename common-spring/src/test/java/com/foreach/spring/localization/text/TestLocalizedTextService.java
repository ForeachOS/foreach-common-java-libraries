package com.foreach.spring.localization.text;

import com.foreach.spring.localization.AbstractLocalizationTest;
import com.foreach.spring.localization.MyLanguage;
import org.junit.Before;
import org.junit.Test;

import java.util.Arrays;
import java.util.concurrent.ExecutorService;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

public class TestLocalizedTextService extends AbstractLocalizationTest
{
	private LocalizedTextDataStore textDao;
	private AbstractLocalizedTextService textService;

	@Before
	public void setUp()
	{
		textDao = mock( LocalizedTextDataStore.class );

		textService = new LocalizedTextServiceImpl( textDao );
	}

	@Test
	public void createTextSet()
	{
		LocalizedText existing = new LocalizedText();
		existing.setLabel( "existing" );
		existing.setUsed( true );

		when( textDao.getLocalizedTextForGroup( "myapp", "mygroup" ) ).thenReturn( Arrays.asList( existing ) );

		LocalizedTextSet textSet = textService.getLocalizedTextSet( "myapp", "mygroup" );

		assertTrue( textSet instanceof LocalizedTextSetImpl );
		assertNotNull( textSet );
		assertEquals( 1, textSet.size() );
		assertEquals( "myapp", textSet.getApplication() );
		assertEquals( "mygroup", textSet.getGroup() );
		assertSame( textService, ( (LocalizedTextSetImpl) textSet ).getLocalizedTextService() );
		assertTrue( textSet.exists( "existing" ) );
	}

	@Test
	public void textSetShouldComeFromCacheIfPossible()
	{
		LocalizedTextSetCache cache = mock( LocalizedTextSetCache.class );
		LocalizedTextSet expected = mock( LocalizedTextSet.class );

		textService.setTextSetCache( cache );

		when( cache.getLocalizedTextSet( "myapp", "mygroup" ) ).thenReturn( expected );

		LocalizedTextSet textSet = textService.getLocalizedTextSet( "myapp", "mygroup" );
		assertSame( expected, textSet );

		verifyZeroInteractions( textDao );
	}

	@Test
	public void textSetShouldBeStoredInCacheIfCreated()
	{
		LocalizedTextSetCache cache = mock( LocalizedTextSetCache.class );
		textService.setTextSetCache( cache );

		LocalizedText existing = new LocalizedText();
		existing.setLabel( "existing" );
		existing.setUsed( true );

		when( textDao.getLocalizedTextForGroup( "myapp", "mygroup" ) ).thenReturn( Arrays.asList( existing ) );

		LocalizedTextSet textSet = textService.getLocalizedTextSet( "myapp", "mygroup" );

		verify( cache, times( 1 ) ).storeLocalizedTextSet( textSet );
	}

	@Test
	public void settingNullCacheShouldNotBreakThings()
	{
		textService.setTextSetCache( null );

		// Even though we set the cache to null, text set fetching behavior should be same as default
		createTextSet();
	}

	@Test
	public void ifItemExistsItWillBeReturnedInsteadOfCreated()
	{
		LocalizedText existing = new LocalizedText();

		when( textDao.getLocalizedText( "myapp", "mygroup", "mylabel" ) ).thenReturn( existing );

		LocalizedText text = textService.saveDefaultText( "myapp", "mygroup", "mylabel", "default" );

		assertSame( existing, text );
	}

	@Test
	public void createNewItem()
	{
		LocalizedText text = textService.saveDefaultText( "myapp", "mygroup", "mylabel", "default" );

		assertNotNull( text );
		assertEquals( "myapp", text.getApplication() );
		assertEquals( "mygroup", text.getGroup() );
		assertEquals( "mylabel", text.getLabel() );
		assertTrue( text.isUsed() );
		assertTrue( text.isAutoGenerated() );
		assertNotNull( text.getCreated() );
		assertEquals( "default", text.getFieldsForLanguage( MyLanguage.EN ).getText() );
		assertEquals( "default", text.getFieldsForLanguage( MyLanguage.FR ).getText() );

		verify( textDao, times( 1 ) ).insertLocalizedText( text );
	}

	@Test
	public void createShouldFailSilently()
	{
		doThrow( new RuntimeException( "Insert failed" ) ).when( textDao ).insertLocalizedText(
				any( LocalizedText.class ) );

		LocalizedText text = textService.saveDefaultText( "myapp", "mygroup", "mylabel", "default" );

		assertNotNull( text );
		assertEquals( "myapp", text.getApplication() );
		assertEquals( "mygroup", text.getGroup() );
		assertEquals( "mylabel", text.getLabel() );
		assertTrue( text.isUsed() );
		assertTrue( text.isAutoGenerated() );
		assertNotNull( text.getCreated() );
	}

	@Test
	public void flagAsUsed()
	{
		LocalizedText text = new LocalizedText();
		assertFalse( text.isUsed() );
		assertNull( text.getUpdated() );

		textService.flagAsUsed( text );

		assertTrue( text.isUsed() );
		assertNotNull( text.getUpdated() );

		verify( textDao, times( 1 ) ).flagAsUsed( text );
	}

	@Test
	public void flagAsUsedShouldUseTheExecutorService()
	{
		ExecutorService executorService = mock( ExecutorService.class );

		textService.setFlaggingExecutorService( executorService );

		LocalizedText text = new LocalizedText();
		assertFalse( text.isUsed() );
		assertNull( text.getUpdated() );

		textService.flagAsUsed( text );

		// Properties should still be set
		assertTrue( text.isUsed() );
		assertNotNull( text.getUpdated() );

		// Dao should never have been called, but the executorService should have been
		verify( textDao, never() ).flagAsUsed( text );
		verify( executorService, times( 1 ) ).submit( any( Runnable.class ) );
	}

	@Test
	public void settingNullExecutorServiceShouldNotBreakThings()
	{
		textService.setFlaggingExecutorService( null );

		// Flag as used behavior should be same as default even with null ExecutorService
		flagAsUsed();
	}

	private class LocalizedTextServiceImpl extends AbstractLocalizedTextService
	{
		private LocalizedTextServiceImpl( LocalizedTextDataStore localizedTextDao )
		{
			super( localizedTextDao );
		}
	}
}
